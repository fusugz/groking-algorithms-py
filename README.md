Groking algorithms learning by python

# 二分法
* 二分法查找的速度比简单查找快得多。
* O(log n)比O(n)快，需要搜索的元素越多，前者比后者就快得越多。
* 算法运行时间并不以秒为单位。
* 算法运行时间是从其增速的角度衡量的。
* 算法运行时间用大O表示法表示。

# 选择排序
* 计算机内存犹如一大堆抽屉。
* 需要存储多个元素时，可使用数组或链表。
* 数组的元素都在一起，是连续的。
* 链表的元素是分开的，其中每个元素都存储了下一个元素的地址。
* 数组的读取速度很快。
* 链表的插入和删除速度很快。
* 在同一个数组中，所有元素的类型都必须相同

# 递归
* 递归指的是调用自己的函数。
* 每个递归函数都有两个条件：基线条件和递归条件。
* 栈有两种操作：压入和弹出。
* 所有的函数调用都进入调用栈。
* 调用栈可能很长，这将占用大量内存。

# 快速排序
* D&C将问题逐步分解。使用D&C处理列表时，基线条件很可能是空数组或只包含一个元素的数组。
* 实现快速排序时，请随机地选择用基准值的元素。快速排序的平均运行时间为O（n log n）。
* 大O表示法中的常量有时候事关重大，这就是快速排序比合并排序快的原因所在。
* 比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长时，O(log n)的速度比O(n)快得多。


